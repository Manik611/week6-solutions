#include <stdio.h>
#include <stdbool.h>

#define MAX 100 

typedef struct {
    int arr[MAX];
    int front;
    int rear;
    int size;
} Queue;


void initQueue(Queue* q, int n) {
    q->front = -1;
    q->rear = -1;
    q->size = n;
}

bool isEmpty(Queue* q) {
    return q->front == -1;
}

bool isFull(Queue* q) {
    return ((q->rear + 1) % q->size == q->front);
}

void enqueue(Queue* q, int x) {
    if (isFull(q)) {
      
        return;
    }
    if (isEmpty(q)) {
        q->front = 0;
    }
    q->rear = (q->rear + 1) % q->size;
    q->arr[q->rear] = x;
}

void dequeue(Queue* q) {
    if (isEmpty(q)) {
        return;
    }
    if (q->front == q->rear) {
        q->front = -1;
        q->rear = -1;
    } else {
        q->front = (q->front + 1) % q->size;
    }
}
int getFront(Queue* q) {
    if (isEmpty(q))
        return -1;
    return q->arr[q->front];
}

int getRear(Queue* q) {
    if (isEmpty(q))
        return -1;
    return q->arr[q->rear];
}
int main() {
    int n = 3; 
    int queries[][2] = {{1, 5}, {1, 3}, {1, 4}, {3, -1}, {2, -1}, {5, -1}, {4, -1}};
    int q_count = 7;

    Queue q;
    initQueue(&q, n);

    for (int i = 0; i < q_count; i++) {
        int type = queries[i][0];
        int val = queries[i][1];
        switch(type) {
            case 1: enqueue(&q, val); break;
            case 2: dequeue(&q); break;
            case 3: printf("%d\n", getFront(&q)); break;
            case 4: printf("%d\n", getRear(&q)); break;
            case 5: printf("%s\n", isEmpty(&q) ? "true" : "false"); break;
            case 6: printf("%s\n", isFull(&q) ? "true" : "false"); break;
        }
    }

    return 0;
}
